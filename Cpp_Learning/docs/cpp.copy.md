### C++ 拷贝问题核心总结（完整逻辑+核心思想）
我们围绕“自定义String类的拷贝问题”展开的所有讨论，本质是拆解C++拷贝语义的两大核心维度：**拷贝的「可行性」（编译层面能否拷贝）** 和**拷贝的「安全性」（运行层面是否崩溃）**，以下是完整且结构化的总结：

#### 一、拷贝的两大核心维度（先分清“能不能拷贝”和“拷贝安不安全”）
| 维度         | 核心问题                          | 决定因素                                                                 |
|--------------|-----------------------------------|--------------------------------------------------------------------------|
| 可行性（编译） | 能否调用拷贝相关函数？| 特殊成员函数生成规则（编译器是否自动生成/删除拷贝构造/赋值运算符）|
| 安全性（运行） | 拷贝后是否崩溃/数据错乱？| 是否包含动态内存（浅拷贝对动态内存危险，深拷贝安全；无动态内存则浅拷贝安全） |

#### 二、浅拷贝 vs 深拷贝（拷贝安全性的核心）
这是运行层面的核心矛盾，也是自定义String类（含`char*`动态内存）的核心坑点：
1. **浅拷贝（编译器默认行为）**
   - 本质：逐字节复制成员变量（如`obj_copy.str`直接指向`obj.str`的内存）；
   - 适用场景：仅无动态内存的简单类（如Person类，无`new`/`new[]`）；
   - 风险（对String类）：多个对象共享同一块动态内存 → 数据互相篡改、析构时`double free`崩溃。

2. **深拷贝（手动实现）**
   - 本质：为新对象分配独立的动态内存，再复制源对象的数据；
   - 适用场景：所有包含动态内存的类（如String类）；
   - 效果：对象间内存独立，修改互不影响，析构无重复释放问题。

#### 三、拷贝构造 vs 赋值运算符（拷贝可行性的核心）
两者都处理“对象拷贝”，但**调用时机完全不同**（最易混淆的“等号语义”也在此处）：
| 函数类型                | 语法形式                          | 核心作用                  | 调用场景（关键区分）| 参数`other`的含义               |
|-------------------------|-----------------------------------|---------------------------|---------------------------------------------|----------------------------------|
| 拷贝构造函数            | `String(const String& other)`     | 用已有对象**创建新对象**  | 1. `String obj_copy = obj;`（新对象初始化）<br>2. `String obj_copy(obj);`（括号初始化） | 被拷贝的源对象（const引用：只读+避免递归拷贝） |
| 拷贝赋值运算符          | `String& operator=(const String& other)` | 给**已存在的对象**赋值    | 1. `obj2 = obj1;`（obj2已创建，仅更新内容）<br>2. 连续赋值（`obj3 = obj2 = obj1;`） | 被赋值的源对象（同上）|

**关键易错点：等号的两种语义**
- 新对象的等号（如`String obj_copy = obj;`）：是拷贝构造的语法糖，调用拷贝构造，而非赋值运算符；
- 已有对象的等号（如`obj2 = obj1;`）：是真正的赋值操作，调用赋值运算符。

#### 四、特殊成员函数生成规则（决定拷贝可行性）
编译器是否自动生成拷贝构造/赋值运算符，只看是否自定义了「析构/拷贝/移动」类特殊成员函数（和普通函数如`add()`/`print()`无关）：
1. 核心规则：
   - 未自定义任何特殊成员函数：编译器自动生成浅拷贝构造+赋值运算符；
   - 自定义析构函数（如`~String()`）：C++11及以后，编译器**弃用/删除**默认拷贝构造/赋值运算符（严格模式编译报错）；
   - 自定义拷贝构造：编译器停止生成赋值运算符（反之亦然）。
2. 编译器兼容问题：
   - 非严格模式（如未加`-Werror`）：旧编译器/C++版本为兼容旧代码，仍会生成浅拷贝构造/赋值，编译能通过，但运行仍崩；
   - 严格模式（如`g++ -std=c++20 -Werror`）：直接编译报错（找不到拷贝构造/赋值运算符）。

#### 五、`=default` vs `=delete`（手动控制拷贝可行性）
两者都是C++11新增语法，用于显式控制编译器的特殊成员函数生成：
| 语法写法                          | 作用                                  | 适用场景                                                                 |
|-----------------------------------|---------------------------------------|--------------------------------------------------------------------------|
| `String(const String&) = default;` | 强制编译器生成默认浅拷贝构造          | 无动态内存的类（如Person），且因自定义析构导致编译器停更生成拷贝构造时（恢复拷贝可行性） |
| `String& operator=(const String&) = default;` | 强制编译器生成默认浅拷贝赋值运算符    | 同上（恢复赋值可行性）|
| `String(const String&) = delete;`  | 禁用拷贝构造                          | 包含动态内存且不需要拷贝的类（从源头避免浅拷贝风险）|
| `String& operator=(const String&) = delete;` | 禁用赋值运算符                        | 同上                                                                     |

**关键提醒**：`=default`仅解决“编译可行性”，不解决“运行安全性”——对String类，`=default`生成的浅拷贝仍会导致`double free`，只有手动深拷贝才是正解。

#### 六、自定义String类的正确拷贝实现（最终解决方案）
对包含动态内存的String类，必须手动实现**深拷贝构造+深拷贝赋值运算符**，核心逻辑：
```cpp
// 1. 深拷贝构造（创建新对象）
String(const String& other) {
    maxsize = other.maxsize;
    length = other.length;
    str = new char[maxsize]; // 分配独立内存
    for (int i=0; i<=length; i++) {
        str[i] = other.str[i]; // 复制数据
    }
}

// 2. 深拷贝赋值（更新已有对象，需先释放当前内存）
String& operator=(const String& other) {
    if (this == &other) return *this; // 自赋值保护
    delete[] str; // 释放当前对象的旧内存
    // 以下同拷贝构造
    maxsize = other.maxsize;
    length = other.length;
    str = new char[maxsize];
    for (int i=0; i<=length; i++) {
        str[i] = other.str[i];
    }
    return *this; // 支持连续赋值
}
```

#### 七、核心思想（一句话记死）
1. 无动态内存的类：靠`=default`恢复拷贝可行性（浅拷贝安全），无需手动实现；
2. 有动态内存的类：`=default`仅解决编译，必须手动深拷贝解决运行安全；
3. 不想拷贝的类：直接`=delete`禁用拷贝，从源头避免风险；
4. 区分拷贝构造和赋值运算符：新对象的等号=拷贝构造，老对象的等号=赋值运算符。

#### 八、新手避坑关键
- 不要认为“能编译的代码就是对的”：浅拷贝导致的`double free`是“编译过、运行崩”的典型隐蔽错误；
- 不要混淆“特殊成员函数”和“普通函数”：只有析构/拷贝/移动会影响编译器的拷贝函数生成，`add()`/`print()`等普通函数无影响；
- 不要依赖编译器默认的浅拷贝：只要类里有`new`/`new[]`，就必须手动实现深拷贝（或禁用拷贝）。